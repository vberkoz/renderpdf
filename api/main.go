package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"golang.org/x/net/html"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/chromedp/cdproto/page"
	"github.com/chromedp/cdproto/emulation"
	"github.com/chromedp/chromedp"
	"github.com/google/uuid"
)

type Request struct {
	HTML string `json:"html"`
}

type Response struct {
	RequestID string `json:"requestId"`
	URL       string `json:"url"`
	Size      int64  `json:"size"`
}

var (
	bucketName = os.Getenv("BUCKET_NAME")
	tableName  = os.Getenv("TABLE_NAME")
	sess       = session.Must(session.NewSession())
	s3Client   = s3.New(sess)
	ddbClient  = dynamodb.New(sess)
)

func handler(ctx context.Context, request events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	var req Request
	if err := json.Unmarshal([]byte(request.Body), &req); err != nil {
		return events.APIGatewayProxyResponse{StatusCode: 400, Body: "Invalid request"}, nil
	}

	requestID := uuid.New().String()
	html := injectPrintCSS(req.HTML)
	html = ensureColgroup(html)
	html = rewriteTfoot(html)
	pdfBytes, err := generatePDF(ctx, html)
	if err != nil {
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: err.Error()}, nil
	}

	key := fmt.Sprintf("%s.pdf", requestID)
	_, err = s3Client.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(bucketName),
		Key:    aws.String(key),
		Body:   bytes.NewReader(pdfBytes),
	})
	if err != nil {
		return events.APIGatewayProxyResponse{StatusCode: 500, Body: err.Error()}, nil
	}

	url := fmt.Sprintf("https://%s.s3.amazonaws.com/%s", bucketName, key)
	trackUsage(requestID, int64(len(pdfBytes)))

	resp := Response{RequestID: requestID, URL: url, Size: int64(len(pdfBytes))}
	body, _ := json.Marshal(resp)

	return events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       string(body),
		Headers:    map[string]string{"Content-Type": "application/json"},
	}, nil
}

func generatePDF(ctx context.Context, html string) ([]byte, error) {
	chromePath := "/usr/bin/google-chrome-stable"
	if _, err := os.Stat(chromePath); os.IsNotExist(err) {
		chromePath = "/opt/google/chrome/chrome"
		if _, err := os.Stat(chromePath); os.IsNotExist(err) {
			return nil, fmt.Errorf("chrome binary not found")
		}
	}
	fmt.Printf("Using Chrome at: %s\n", chromePath)

	opts := []chromedp.ExecAllocatorOption{
		chromedp.ExecPath(chromePath),
		chromedp.NoSandbox,
		chromedp.NoFirstRun,
		chromedp.NoDefaultBrowserCheck,
		chromedp.Headless,
		chromedp.DisableGPU,
		chromedp.Flag("disable-dev-shm-usage", true),
		chromedp.Flag("disable-software-rasterizer", true),
		chromedp.Flag("no-zygote", true),
		chromedp.Flag("single-process", true),
		chromedp.UserDataDir("/tmp/chrome-data"),
		chromedp.WindowSize(1920, 1080),
	}

	fmt.Println("Creating Chrome allocator...")
	allocCtx, allocCancel := chromedp.NewExecAllocator(ctx, opts...)
	defer allocCancel()

	fmt.Println("Creating Chrome context...")
	taskCtx, taskCancel := chromedp.NewContext(allocCtx)
	defer taskCancel()

	timeoutCtx, timeoutCancel := context.WithTimeout(taskCtx, 25*time.Second)
	defer timeoutCancel()

	var buf []byte
	escaped := url.PathEscape(html)

	fmt.Println("Running chromedp...")
	err := chromedp.Run(timeoutCtx,
		chromedp.Navigate("data:text/html;charset=utf-8,"+escaped),
		chromedp.ActionFunc(func(ctx context.Context) error {
			return emulation.SetDeviceMetricsOverride(
				1920,
				1080,
				1,
				false,
			).WithScreenOrientation(
				&emulation.ScreenOrientation{
					Type:  emulation.OrientationTypePortraitPrimary,
					Angle: 0,
				},
			).Do(ctx)
		}),
		chromedp.ActionFunc(func(ctx context.Context) error {
			return emulation.SetEmulatedMedia().WithMedia("print").Do(ctx)
		}),
		chromedp.Evaluate(`document.body.offsetHeight`, nil),
		chromedp.Sleep(300*time.Millisecond),
		chromedp.ActionFunc(func(ctx context.Context) error {
			var err error
			buf, _, err = page.PrintToPDF().
				WithPrintBackground(true).
				WithPreferCSSPageSize(true).
				WithScale(1).
				WithDisplayHeaderFooter(true).
				WithHeaderTemplate(`<div style="font-size:10px;width:100%;padding:0 0.5cm;display:flex;justify-content:space-between;"><span class="title"></span><span class="date"></span></div>`).
				WithFooterTemplate(`<div style="font-size:10px;width:100%;padding:0 0.5cm;display:flex;justify-content:space-between;"><span>Generated by RenderPDF</span><span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span></div>`).
				WithMarginTop(0.5).
				WithMarginBottom(0.5).
				WithMarginLeft(0).
				WithMarginRight(0).
				Do(ctx)
			return err
		}),
	)

	return buf, err
}

func rewriteTfoot(htmlStr string) string {
	doc, err := html.Parse(strings.NewReader(htmlStr))
	if err != nil {
		return htmlStr
	}

	var walk func(*html.Node)
	walk = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "tfoot" {
			n.Data = "tbody"
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			walk(c)
		}
	}
	walk(doc)

	var buf bytes.Buffer
	html.Render(&buf, doc)
	return buf.String()
}

func ensureColgroup(html string) string {
	re := regexp.MustCompile(`(?i)<table([^>]*)>`)
	return re.ReplaceAllStringFunc(html, func(m string) string {
		if strings.Contains(strings.ToLower(html[strings.Index(html, m):]), "<colgroup") {
			return m
		}
		return m + `<colgroup><col style="width:40%"><col style="width:20%"><col style="width:20%"><col style="width:20%"></colgroup>`
	})
}

func injectPrintCSS(html string) string {
	if strings.Contains(html, "__RENDERPDF_INJECTED__") {
		return html
	}

	const css = `<!-- __RENDERPDF_INJECTED__ -->
<style id="__lambda_print_fix__">
@media print {
  * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    forced-color-adjust: none !important;
  }
  table {
    table-layout: fixed !important;
    width: 100% !important;
  }
  tfoot {
    display: table-row-group !important;
  }
  tr {
    break-inside: avoid !important;
    page-break-inside: avoid !important;
  }
}
</style>
`

	if strings.Contains(html, "</head>") {
		return strings.Replace(html, "</head>", css+"</head>", 1)
	}

	return css + html
}

func trackUsage(requestID string, size int64) {
	ddbClient.PutItem(&dynamodb.PutItemInput{
		TableName: aws.String(tableName),
		Item: map[string]*dynamodb.AttributeValue{
			"requestId": {S: aws.String(requestID)},
			"timestamp": {N: aws.String(fmt.Sprintf("%d", time.Now().Unix()))},
			"size":      {N: aws.String(fmt.Sprintf("%d", size))},
		},
	})
}

func main() {
	lambda.Start(handler)
}
